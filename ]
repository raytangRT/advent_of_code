defmodule Day18.Part2 do
  import HeapGuards
  alias Grid.Cell

  def read(width, height, rows_to_take, mode \\ :sample) do
    AOC.read_file(mode, "day18")
    |> Enum.take(rows_to_take)
    |> Enum.reduce(Grid.new(width, height, AOC.f2({:inf, :safe})), fn pair, grid ->
      point = String.split(pair, ",") |> List.to_tuple() |> Point.new()
      Grid.replace(grid, point, {:inf, :corrupted})
    end)
    |> Grid.replace(Point.new(0, 0), {:inf, :end})
    |> Grid.replace(Point.new(width, height), {0, :start})
  end

  def print_grid(grid) do
    grid
    |> Grid.print(fn %Cell{value: {distance, value}} ->
      case value do
        :safe ->
          if distance == :inf,
            do: " . ",
            else: distance |> Integer.to_string() |> String.pad_leading(3)

        :corrupted ->
          " # "

        :start ->
          " S "

        :end ->
          " E "

        :path ->
          "O"
      end
    end)
  end

  def get_cell(grid, type) do
    Grid.get_cells(
      grid,
      fn %Cell{value: {_, value}} ->
        value == type
      end
    )
    |> hd()
  end

  def walk(grid) when is_struct(grid, Grid) do
    starting_cell = get_cell(grid, :start)

    heap =
      Heap.new(fn %Cell{value: {l_distance, _}}, %Cell{value: {r_distance, _}} ->
        l_distance < r_distance
      end)
      |> Heap.push(starting_cell)

    walk({grid, heap})
  end

  def walk({grid, heap} = input) when is_tuple(input) and is_empty_heap(heap) do
    grid
  end

  def walk({grid, heap} = input) when is_tuple(input) and is_struct(grid, Grid) do
    {%Cell{point: point, value: {distance, _}}, heap} = Heap.split(heap)

    [
      Point.move_left(point),
      Point.move_right(point),
      Point.move_up(point),
      Point.move_down(point)
    ]
    |> Enum.map(&Grid.get_cell(grid, &1))
    |> Enum.reject(fn cell ->
      is_nil(cell) or Cell.value(cell) == {:inf, :corrupted}
    end)
    |> Enum.reduce({grid, heap}, fn %Cell{point: point, value: {current_distance, t}},
                                    {grid, heap} ->
      new_distance = distance + 1

      if current_distance > new_distance do
        grid = Grid.replace(grid, point, {new_distance, t})
        heap = Heap.push(heap, Grid.get_cell(grid, point))
        {grid, heap}
      else
        {grid, heap}
      end
    end)
    |> walk()
  end

  def calculate_path(grid) do
    end_cell = get_cell(grid, :end)
    calculate_path(grid, [end_cell])
  end

  def calculate_path(_grid, [%Cell{value: {_, value}} | _] = path) when value == :start do
    path
    |> Enum.map(fn %Cell{point: point} ->
      point
    end)
  end

  def calculate_path(grid, [%Cell{point: point} | _] = path) do
    next_cell =
      [
        Point.move_left(point),
        Point.move_right(point),
        Point.move_up(point),
        Point.move_down(point)
      ]
      |> Enum.map(&Grid.get_cell(grid, &1))
      |> Enum.reject(fn cell ->
        is_nil(cell) or Cell.value(cell) == {:inf, :corrupted}
      end)
      |> Enum.min_by(fn %Cell{value: {distance, _}} -> distance end)

    calculate_path(grid, [next_cell | path])
  end

  def skip(rows_to_skip, mode \\ :sample) do
    AOC.read_file(mode, "day18")
    |> Enum.split(rows_to_skip)
    |> elem(1)
    |> Enum.map(&Point.new(String.split(&1, ",") |> List.to_tuple()))
  end

  def run(width, memory_size, mode \\ :sample) do
    grid = read(width, width, memory_size, mode) |> walk()
    current_path = calculate_path(grid)
    to_skip = skip(memory_size, mode)
    rewalk(grid, current_path, to_skip)
  end

  def rewalk(grid, _path, to_skips) when length(to_skips) == 0 do
    grid
  end

  def rewalk(grid, path, [head | rest] = to_skips) do
    index = Enum.find_index(path, &(&1 == head))
    grid = Grid.replace(grid, head, {:inf, :corrupted})
    {success, new_list} = ListUtils.remove_by_value(path, head)

    if index == nil do
      rewalk(grid, path, rest)
    else
      IO.puts("#{index} == #{inspect(path)}")
      {front, [_, tail]} = Enum.split(path, index)

      new_grid =
        Enum.reduce(tail, grid, fn p, grid ->
          Grid.replace(grid, p, {:inf, :corrupted})
        end)

      front = Enum.reverse(front)
      new_grid = walk({new_grid, Heap.new() |> Heap.push(hd(front))})
      new_grid
    end
  end
end
